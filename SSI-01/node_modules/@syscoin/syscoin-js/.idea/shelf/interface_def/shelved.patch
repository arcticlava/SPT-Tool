Index: src/rpcServices.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import { AssetAllocationBalanceQuery, AssetAllocationBalanceQueryWithGuid, AssetAllocationSend, EthHeaders, ListAssetIndexOptions, ListAssetOptions, PbstPayloadInfo, RawTx, TpsRawTx, Transaction, TxHeader } from \"./index\";\n\nexport function rpcServices(callRpc) {\n  return {\n    // @formatter:off\n    // == Blockchain ==\n    getBestBlockHash(): Promise<any> { return callThroughToRpc(arguments) },\n    getBlock({blockHash, verbosity}: { blockHash: string, verbosity?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    getBlockchainInfo(): Promise<any> { return callThroughToRpc(arguments) },\n    getBlockCount(): Promise<any> { return callThroughToRpc(arguments) },\n    getBlockFilter({blockHash, filterType}: { blockHash: string, filterType?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getBlockHash({height}: { height: number }): Promise<any> { return callThroughToRpc(arguments) },\n    getBlockHeader({blockHash, verbose}: { blockHash: string, verbose?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    getBlockStats({hashOrHeight, stats}: { hashOrHeight: string, stats?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    getChainTips({count, branchLength}: { count?: number, branchLength?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    getChainTxStats({nBlocks, blockHash}: { nBlocks?: number, blockHash?: number}): Promise<any> { return callThroughToRpc(arguments) },\n    getDifficulty(): Promise<any> { return callThroughToRpc(arguments) },\n    getMemPoolAncestors({txid, verbose}: { txid: string, verbose?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    getMemPoolDescendants({txid, verbose}: { txid: string, verbose?: number}): Promise<any> { return callThroughToRpc(arguments) },\n    getMemPoolEntry({txid}: { txid: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getMemPoolInfo(): Promise<any> { return callThroughToRpc(arguments) },\n    getRawMemPool({verbose}: { verbose?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    getTxOut({txid, voutNumber, includeMempool}: { txid: string, voutNumber: number, includeMempool?: boolean }): Promise<any> { return callThroughToRpc(arguments) },\n    getTxOutProof({txids, blockHash}: { txids: Array<string>, blockHash: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getTxOutSetInfo(): Promise<any> { return callThroughToRpc(arguments) },\n    preciousBlock({blockHash}: { blockHash: string }): Promise<any> { return callThroughToRpc(arguments) },\n    pruneBlockchain({blockHeight}: { blockHeight: number }): Promise<any> { return callThroughToRpc(arguments) },\n    saveMemPool(): Promise<any> { return callThroughToRpc(arguments) },\n    scanTxOutSet({action, scanObjects}: { action: string, scanObjects: Array<any>}) { return callThroughToRpc(arguments) },\n    verifyChain({checkLevel, numberOfBlocksToCheck}: { checkLevel?: number, numberOfBlocksToCheck?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    verifyTxOutProof({proof}: { proof: string }): Promise<any> { return callThroughToRpc(arguments) },\n\n    // == Control ==\n    getMemoryInfo({mode}: { mode?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getRpcInfo(): Promise<any> { return callThroughToRpc(arguments) },\n    help({command}: { command?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    logging({includeCategories, excludeCategories}: { includeCategories?: Array<string>, excludeCategories: Array<string> }): Promise<any> { return callThroughToRpc(arguments) },\n    stop(): Promise<any> { return callThroughToRpc(arguments) },\n    uptime(): Promise<any> { return callThroughToRpc(arguments) },\n\n    // == Generating ==\n    generate({numberOfBlocks, maxTries}: { numberOfBlocks: number, maxTries?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    generateToAddress({numberOfBlocks, address, maxTries}: { numberOfBlocks: number, address: string, maxTries?: number }): Promise<any> { return callThroughToRpc(arguments) },\n\n    // == Mining ==\n    createAuxBlock({address}: { address: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getAuxBlock({blockHash, auxPow}: { blockHash?: string, auxPow?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getBlockTemplate({blockTemplate}: { blockTemplate: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getMiningInfo(): Promise<any> { return callThroughToRpc(arguments) },\n    getNetworkHashesPerSecond({numberOfBlocks, blockHeight}: { numberOfBlocks: number, blockHeight: number }): Promise<any> { return callThroughToRpc(arguments) },\n    prioritiseTransaction({txid, dummy, feeDeltaInSatoshis}: { txid: string, dummy?: null, feeDeltaInSatoshis: number }): Promise<any> { return callThroughToRpc(arguments) },\n    submitAuxBlock({blockHash, auxPow}: { blockHash: string, auxPow: string }): Promise<any> { return callThroughToRpc(arguments) },\n    submitBlock({hexDataToSubmit}: { hexDataToSubmit: string }): Promise<any> { return callThroughToRpc(arguments) },\n    submitHeader({hexData}: { hexData: string }): Promise<any> { return callThroughToRpc(arguments) },\n\n    // == Network ==\n    addNode({nodeAddress}: { nodeAddress: string }): Promise<any> { return callThroughToRpc(arguments) },\n    clearBanned(): Promise<any> { return callThroughToRpc(arguments) },\n    disconnectNode({nodeAddress, nodeId}: { nodeAddress: string, nodeId: number }): Promise<any> { return callThroughToRpc(arguments) },\n    getAddedNodeInfo({nodeAddress}: { nodeAddress: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getConnectionCount(): Promise<any> { return callThroughToRpc(arguments) },\n    getNetTotals(): Promise<any> { return callThroughToRpc(arguments) },\n    getNetworkInfo(): Promise<any> { return callThroughToRpc(arguments) },\n    getNodeAddresses(): Promise<any> { return callThroughToRpc(arguments) },\n    getPeerInfo(): Promise<any> { return callThroughToRpc(arguments) },\n    getInfo(): Promise<any> { return callThroughToRpc(arguments) },\n    listBanned(): Promise<any> { return callThroughToRpc(arguments) },\n    ping(): Promise<any> { return callThroughToRpc(arguments) },\n    setBan({subnet,command,banTime}: { subnet: string, command: string, banTime?: number}):Promise<any> { return callThroughToRpc(arguments) },\n\n    // == Rawtransactions ==\n    analyzePsbt({pbst}: { pbst: string }): Promise<any> { return callThroughToRpc(arguments) },\n    combinePsbt({pbsts}: { pbsts: Array<string> }): Promise<any> { return callThroughToRpc(arguments) },\n    combineRawTransaction({hexs}: { hexs: Array<string> }): Promise<any> { return callThroughToRpc(arguments) },\n    convertToPsbt({hex, permitSigData, isWitness}: { hex: string, permitSigData?: number, isWitness?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    createPsbt({txHeaders, payloadInfo, locktime, replaceable}: { txHeaders: Array<TxHeader>, payloadInfo: Array<PbstPayloadInfo>, locktime?: number, replaceable?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    createRawTransaction({txHeaders, payloadInfo, locktime, replaceable}: { txHeaders: Array<TxHeader>, payloadInfo: Array<PbstPayloadInfo>, locktime?: number, replaceable?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    decodePsbt({pbst}: { pbst: string }): Promise<any> { return callThroughToRpc(arguments) },\n    decodeRawTransaction({hexString, isWitness}: { hexString: string, isWitness: number }): Promise<any> { return callThroughToRpc(arguments) },\n    decodeScript({hexString}: { hexString: string }): Promise<any> { return callThroughToRpc(arguments) },\n    finalizePsbt({pbst, extract}: { pbst: string, extract?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    fundRawTransaction({hexString, options, isWitness}: { hexString: string, options?: number, isWitness?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    getRawTransaction({txid, verbose, blockHash}: { txid: string, verbose?: number, blockHash?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    joinPsbts({pbsts}: { pbsts: Array<string> }): Promise<any> { return callThroughToRpc(arguments) },\n    sendRawTransaction({hexString, maxFeeRate}: { hexString: string, maxFeeRate?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    signRawTransactionWithKey({hexString, privateKeys, txs, sigHashType}: { hexString: string, privateKeys: Array<string>, txs?: Array<Transaction>, sigHashType?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    testMempoolAccept({rawTxs, maxFeeRate}: { rawTxs: Array<string>, maxFeeRate?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    utxoUpdatePsbt({pbst}: { pbst: string }): Promise<any> { return callThroughToRpc(arguments) },\n\n    // == Syscoin ==\n    addressBalance({address}: { address: string }): Promise<any> { return callThroughToRpc(arguments) },\n    assetAllocationBalance({assetGuid, address}: { assetGuid: number, address: string }): Promise<any> { return callThroughToRpc(arguments) },\n    assetAllocationBurn({assetGuid, address, amount, ethAddress}: { assetGuid: number, address: string, amount: number, ethAddress: string }): Promise<any> { return callThroughToRpc(arguments) },\n    assetAllocationInfo({assetGuid, address}: { assetGuid: number, address: string }): Promise<any> { return callThroughToRpc(arguments) },\n    assetAllocationLock({assetGuid, addressFrom, txid, outputIndex, witness}: { assetGuid: number, addressFrom: string, txid: string, outputIndex: number, witness?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    assetAllocationMint({assetGuid, address, amount, blockNum, txHex, txRootHex, merkleProofHex, merkleProofPathHex, witness}: { assetGuid: number, address: string, amount: number, blockNum: number, txHex: string, txRootHex: string, merkleProofHex: string, merkleProofPathHex: string, witness?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    assetAllocationSend({assetGuid, addressFrom, addressTo, amount}: { assetGuid: number, addressFrom: string, addressTo: string, amount: number }): Promise<any> { return callThroughToRpc(arguments) },\n    assetAllocationSenderStatus({assetGuid, address, txid}: { assetGuid: number, address: string, txid: string }): Promise<any> { return callThroughToRpc(arguments) },\n    assetAllocationSendMany({assetGuid, addressFrom, allocations, witness}: { assetGuid: number, addressFrom: string, allocations: Array<AssetAllocationSend>, witness?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    assetInfo({assetGuid}: { assetGuid: number }): Promise<any> { return callThroughToRpc(arguments) },\n    assetNew({address, publicValue, contract, precision, supply, maxSupply, updateFlags, witness}: { address: string, publicValue: string, contract: string, precision: number, supply: number, maxSupply: number, updateFlags: number, witness: string }): Promise<any> { return callThroughToRpc(arguments) },\n    assetSend({assetGuid, addressTo, amount}: { assetGuid: number, addressTo: string, amount: number }): Promise<any> { return callThroughToRpc(arguments) },\n    assetSendMany({assetGuid, allocations, witness}: { assetGuid: number, allocations: Array<AssetAllocationSend>, witness?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    assetTransfer({assetGuid, address, witness}: { assetGuid: number, address: string, witness: string }): Promise<any> { return callThroughToRpc(arguments) },\n    assetUpdate({assetGuid, publicValue, contract, supply, updateFlags, witness}: { assetGuid: number, publicValue: string, contract: string, supply: number, updateFlags: number, witness: string }): Promise<any> { return callThroughToRpc(arguments) },\n    convertAddress({address}: { address: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getBlockHashByTxid({txid}: { txid: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getGovernanceInfo(): Promise<any> { return callThroughToRpc(arguments) },\n    getSuperblockBudget({index}: { index: number }): Promise<any> { return callThroughToRpc(arguments) },\n    gObject({command}: { command: string }): Promise<any> { return callThroughToRpc(arguments) },\n    listAssetAllocationMempoolBalances({count, from, query}: { count?: number, from?: number, query?: AssetAllocationBalanceQuery }): Promise<any> { return callThroughToRpc(arguments) },\n    listAssetAllocations({count, from, query}: { count?: number, from?: number, query?: AssetAllocationBalanceQueryWithGuid }): Promise<any> { return callThroughToRpc(arguments) },\n    listAssetIndex({page, options}: { page?: number, options?: ListAssetIndexOptions }): Promise<any> { return callThroughToRpc(arguments) },\n    listAssetIndexAllocations({address}: { address: string }): Promise<any> { return callThroughToRpc(arguments) },\n    listAssetIndexAssets({address}: { address: string }): Promise<any> { return callThroughToRpc(arguments) },\n    listAssets({count, from, options}: { count?: number, from?: number, options?: ListAssetOptions }): Promise<any> { return callThroughToRpc(arguments) },\n    masternode({command}: { command: string }): Promise<any> { return callThroughToRpc(arguments) },\n    masternodeBroadcast({command}: { command: string }): Promise<any> { return callThroughToRpc(arguments) },\n    masternodeList({mode, filter}: { mode?: string, filter?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    mnSync({command}: { command: string }): Promise<any> { return callThroughToRpc(arguments) },\n    sentinelPing({version}: { version: number }): Promise<any> { return callThroughToRpc(arguments) },\n    spork({command}: { command: string }): Promise<any> { return callThroughToRpc(arguments) },\n    syscoinBurn({fundingAddress, amount, ethAddress}: { fundingAddress: string, amount: number, ethAddress: string }): Promise<any> { return callThroughToRpc(arguments) },\n    syscoinDecodeRawTransaction({hexString}: { hexString: number }): Promise<any> { return callThroughToRpc(arguments) },\n    syscoinGetSpvProof({txid, blockHash}: { txid: string, blockHash?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    syscoinListReceivedByAddress({}: {}): Promise<any> { return callThroughToRpc(arguments) },\n    syscoinMint({address, amount, blockNum, txHex, txRootHex, txMerkleProofHex, witness}: { address: string, amount: number, blockNum: number, txHex: string, txRootHex: string, txMerkleProofHex: string, witness?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    syscoinSetEthHeaders({headers}: { headers: EthHeaders }): Promise<any> { return callThroughToRpc(arguments) },\n    syscoinSetEthStatus({syncStatus, highestBlock}: { syncStatus: string, highestBlock: number }): Promise<any> { return callThroughToRpc(arguments) },\n    syscoinStartGeth({}: {}): Promise<any> { return callThroughToRpc(arguments) },\n    syscoinStopGeth({}: {}): Promise<any> { return callThroughToRpc(arguments) },\n    syscoinTxFund({hexString, address, outputIndex}: { hexString: string, address: string, outputIndex: number }): Promise<any>{ return callThroughToRpc(arguments) },\n    tpsTestAdd({startTime, rawTxs}: { startTime, rawTxs?: Array<TpsRawTx> }): Promise<any> { return callThroughToRpc(arguments) },\n    tpsTestInfo({}: {}): Promise<any> { return callThroughToRpc(arguments) },\n    tpsTestSetEnabled({enabled}: { enabled: number }): Promise<any> { return callThroughToRpc(arguments) },\n    voteRaw({mnTxHash, mnTxIndex, govHash, votSignal, vote, time, voteSig}: { mnTxHash: string, mnTxIndex: number, govHash: string, votSignal: string, vote: string, time: number, voteSig: string }): Promise<any>{ return callThroughToRpc(arguments) },\n\n    // == Util ==\n    createMultiSig({numberOfRequiredSignatures, keys, addressType}: { numberOfRequiredSignatures: number, keys: Array<string>, addressType?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    deriveAddress({descriptor, range}: { descriptor: string, range?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    estimateSmartFee({confTarget, estimateMode}: { confTarget: number, estimateMode?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getDescriptorInfo({descriptor}: { descriptor: string }): Promise<any> { return callThroughToRpc(arguments) },\n    signMessageWithPrivKey({privateKey, message}: { privateKey: string, message: string }): Promise<any> { return callThroughToRpc(arguments) },\n    validateAddress({address}: { address: string }): Promise<any> { return callThroughToRpc(arguments) },\n    verifyMessage({address, signature, message}: { address: string, signature: string, message: string }): Promise<any> { return callThroughToRpc(arguments) },\n\n    // == Wallet ==\n    abandonTransaction({txid}: { txid: string }): Promise<any> { return callThroughToRpc(arguments) },\n    abortRescan(): Promise<any> { return callThroughToRpc(arguments) },\n    addMultiSigAddress({nRequired, keys, label, addressType}: { nRequired: number, keys: Array<string>, label?: string, addressType?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    backupWallet({destination}: { destination: string }): Promise<any> { return callThroughToRpc(arguments) },\n    bumpFee({txid, options}: { txid: string, options?: any }): Promise<any> { return callThroughToRpc(arguments) },\n    createWallet({walletName, disablePrivKeys}: { walletName: string, disablePrivKeys: number }): Promise<any> { return callThroughToRpc(arguments) },\n    dumpPrivKey({address}: { address: string }): Promise<any> { return callThroughToRpc(arguments) },\n    dumpWallet({fileName}: { fileName: string }): Promise<any> { return callThroughToRpc(arguments) },\n    encryptWallet({passphrase}: { passphrase: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getAddressesByLabel({label}: { label: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getAddressInfo({address}: { address: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getBalance({dummy, minconf, includeWatchOnly}: { dummy?: string, minconf: number, includeWatchOnly: number }): Promise<any> { return callThroughToRpc(arguments) },\n    getNewAddress({label, addressType}: { label: string, addressType: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getRawChangeAddress({addressType}: { addressType?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    getReceivedByAddress({address, minConf}: { address: string, minConf?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    getReceivedByLabel({label, minConf}: { label: string, minConf?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    getTransaction({txid, includeWatchOnly}: { txid: string, includeWatchOnly: number }): Promise<any> { return callThroughToRpc(arguments) },\n    getUnconfirmedBalance({}: {}): Promise<any>{ return callThroughToRpc(arguments) },\n    getWalletInfo({}: {}): Promise<any>{ return callThroughToRpc(arguments) },\n    importAddress({address, label, rescan, p2sh}: { address: string, label?: string, rescan?: number, p2sh?: number }): Promise<any>{ return callThroughToRpc(arguments) },\n    importMulti({requests, options}: { requests: string, options: any }): Promise<any> { return callThroughToRpc(arguments) },\n    importPrivKey({key, label, rescan}: { key: string, label?: string, rescan?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    importPrunedFunds({rawTx, txOutProof}: { rawTx: string, txOutProof: string }): Promise<any> { return callThroughToRpc(arguments) },\n    importPubKey({pubKey, label, rescan}: { pubKey: string, label?: string, rescan?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    importWallet({fileName}: { fileName: string }): Promise<any>{ return callThroughToRpc(arguments) },\n    keypoolRefill({newSize}: { newSize?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    listAddressGroupings({}: {}): Promise<any>{ return callThroughToRpc(arguments) },\n    listLabels({purpose}: { purpose?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    listLockUnspent({}: {}): Promise<any> { return callThroughToRpc(arguments) },\n    listReceivedByAddress({minConf, includeEmpty, includeWatchOnly, addressFilter}: { minConf?: number, includeEmpty?: number, includeWatchOnly?: number, addressFilter?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    listReceivedByLabel({minConf, includeEmpty, includeWatchOnly}: { minConf?: number, includeEmpty?: number, includeWatchOnly?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    listSinceBlock({blockHash, targetConfs, includeWatchOnly, includeRemoved}: { blockHash?: string, targetConfs?: number, includeWatchOnly?: number, includeRemoved?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    listTransactions({label, count, skip, includeWatchOnly}: { label?: string, count?: number, skip?: number, includeWatchOnly?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    listUnspent({minConf, maxConf, addresses, includeUnsafe, query, options}: { minConf?: number, maxConf?: number, addresses?: Array<string>, includeUnsafe?: number, query?: any, options?: any }): Promise<any> { return callThroughToRpc(arguments) },\n    listWalletDir({}: {}): Promise<any> { return callThroughToRpc(arguments) },\n    listWallets({}: {}): Promise<any> { return callThroughToRpc(arguments) },\n    loadWallet({fileName}: { fileName: string }): Promise<any> { return callThroughToRpc(arguments) },\n    lockUnspent({unlock, txs}: { unlock: number, txs?: Array<{ txid: string, vout: number }> }): Promise<any> { return callThroughToRpc(arguments) },\n    removePrunedFunds({txid}: { txid: string }): Promise<any> { return callThroughToRpc(arguments) },\n    rescanBlockchain({start, stop}: { start?: number, stop?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    sendMany({dummy, amounts, minConf, comment, subtractFeeFrom, replaceable, confTarget, estimateMode}: { dummy: string, amounts: Array<{ [address: string]: number }>, minConf?: number, comment?: string, subtractFeeFrom?: Array<string>, replaceable?: boolean, confTarget?: number, estimateMode?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    sendToAddress({address, amount, minConf, comment, comment_to, subtractFeeFromAmount, replaceable, confTarget, estimateMode}: { address: string, amount: number, minConf?: number, comment?: string, comment_to?: string, subtractFeeFromAmount?: number, replaceable?: boolean, confTarget?: number, estimateMode?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    setHdSeed({newKeyPool, seed}: { newKeyPool?: number, seed?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    setLabel({address, label}: { address: string, label: string }): Promise<any> { return callThroughToRpc(arguments) },\n    setTxFee({amount}: { amount: number }): Promise<any> { return callThroughToRpc(arguments) },\n    signMessage({address, message}: { address: string, message: string }): Promise<any> { return callThroughToRpc(arguments) },\n    signRawTransactionWithWallet({hexString, rawTxs, sigHashType}: { hexString: string, rawTxs?: Array<RawTx>, sigHashType?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    unloadWallet({walletName}: { walletName?: string }): Promise<any> { return callThroughToRpc(arguments) },\n    walletCreateFundedPsbt({txs, amounts, lockTime, options, bip32derivs}: { txs: any, amounts: any, lockTime?: any, options?: any, bip32derivs?: any }): Promise<any> { return callThroughToRpc(arguments) },\n    walletLock({}: {}): Promise<any> { return callThroughToRpc(arguments) },\n    walletPassphrase({passphrase, timeout}: { passphrase: string, timeout: number }): Promise<any> { return callThroughToRpc(arguments) },\n    walletPassphraseChange({oldPass, newPass}: { oldPass: string, newPass: string }): Promise<any> { return callThroughToRpc(arguments) },\n    walletProcessPsbt({pbst, sign, sigHashType, bip32derivs}: { pbst: string, sign?: number, sigHashType?: string, bip32derivs?: number }): Promise<any> { return callThroughToRpc(arguments) },\n    // @formatter:on\n\n    callThroughToRpc //exposed for unit testing\n  };\n\n  function callThroughToRpc(args): Promise<any> {\n    let argArr: Array<any> = Array.prototype.slice.call(args);\n\n    //expect arg array to be a single object\n    if(argArr.length > 1 && typeof argArr[0] !== 'object') {\n      throw new Error(`callThroughToRpc received unknown params: ${JSON.stringify(argArr)}`);\n    }\n\n    let paramArr = [];\n    if(argArr.length > 0) {\n      //get the ordered keys of the object\n      let argObj = argArr[0];\n      let orderedKeys = Reflect.ownKeys(argObj);\n\n      //create an ordered array of just values\n      paramArr = orderedKeys.map((value, index, arr) => argObj[value]);\n    }\n\n    return callRpc(args.callee.name.toLowerCase(), paramArr);\n  }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/rpcServices.ts	(revision 507abd75ed5ea1d96acf1545c54eb5e4200a5a3b)
+++ src/rpcServices.ts	(date 1558123865000)
@@ -1,18 +1,19 @@
 import { AssetAllocationBalanceQuery, AssetAllocationBalanceQueryWithGuid, AssetAllocationSend, EthHeaders, ListAssetIndexOptions, ListAssetOptions, PbstPayloadInfo, RawTx, TpsRawTx, Transaction, TxHeader } from "./index";
+import { RPCServiceFunctions } from "RPCServiceFunctions";
 
-export function rpcServices(callRpc) {
+export function rpcServices(callRpc): RPCServiceFunctions {
   return {
     // @formatter:off
     // == Blockchain ==
-    getBestBlockHash(): Promise<any> { return callThroughToRpc(arguments) },
-    getBlock({blockHash, verbosity}: { blockHash: string, verbosity?: number }): Promise<any> { return callThroughToRpc(arguments) },
+    getBestBlockHash() { return callThroughToRpc(arguments) },
+    getBlock({blockHash, verbosity}): any { return callThroughToRpc(arguments) },
     getBlockchainInfo(): Promise<any> { return callThroughToRpc(arguments) },
     getBlockCount(): Promise<any> { return callThroughToRpc(arguments) },
     getBlockFilter({blockHash, filterType}: { blockHash: string, filterType?: string }): Promise<any> { return callThroughToRpc(arguments) },
     getBlockHash({height}: { height: number }): Promise<any> { return callThroughToRpc(arguments) },
     getBlockHeader({blockHash, verbose}: { blockHash: string, verbose?: number }): Promise<any> { return callThroughToRpc(arguments) },
     getBlockStats({hashOrHeight, stats}: { hashOrHeight: string, stats?: number }): Promise<any> { return callThroughToRpc(arguments) },
-    getChainTips({count, branchLength}: { count?: number, branchLength?: number }): Promise<any> { return callThroughToRpc(arguments) },
+    getChainTips({count, branchLength}): Promise<any> { return callThroughToRpc(arguments) },
     getChainTxStats({nBlocks, blockHash}: { nBlocks?: number, blockHash?: number}): Promise<any> { return callThroughToRpc(arguments) },
     getDifficulty(): Promise<any> { return callThroughToRpc(arguments) },
     getMemPoolAncestors({txid, verbose}: { txid: string, verbose?: number }): Promise<any> { return callThroughToRpc(arguments) },
@@ -203,7 +204,7 @@
     callThroughToRpc //exposed for unit testing
   };
 
-  function callThroughToRpc(args): Promise<any> {
+  function callThroughToRpc(args) {
     let argArr: Array<any> = Array.prototype.slice.call(args);
 
     //expect arg array to be a single object
Index: src/RPCServiceFunctions.ts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/RPCServiceFunctions.ts	(date 1558123865000)
+++ src/RPCServiceFunctions.ts	(date 1558123865000)
@@ -0,0 +1,201 @@
+// @formatter:off
+    // == Blockchain ==
+import { AssetAllocationBalanceQuery, AssetAllocationBalanceQueryWithGuid, AssetAllocationSend, EthHeaders, ListAssetIndexOptions, ListAssetOptions, PbstPayloadInfo, RawTx, TpsRawTx, Transaction, TxHeader } from "./index";
+export interface RPCServiceFunctions {
+    getBlock({blockHash, verbosity}): Promise<any>;
+    getBlockchainInfo(): Promise<any>;
+    getBlockCount(): Promise<any>;
+    getBlockFilter({blockHash, filterType}: { blockHash: string, filterType?: string }): Promise<any>;
+    getBlockHash({height}: { height: number }): Promise<any>;
+    getBlockHeader({blockHash, verbose}: { blockHash: string, verbose?: number }): Promise<any>;
+    getBlockStats({hashOrHeight, stats}: { hashOrHeight: string, stats?: number }): Promise<any>;
+    getChainTips({count, branchLength}: { count?: number, branchLength?: number }): Promise<any>;
+    getChainTxStats({nBlocks, blockHash}: { nBlocks?: number, blockHash?: number}): Promise<any>;
+    getDifficulty(): Promise<any>;
+    getMemPoolAncestors({txid, verbose}: { txid: string, verbose?: number }): Promise<any>;
+    getMemPoolDescendants({txid, verbose}: { txid: string, verbose?: number}): Promise<any>;
+    getMemPoolEntry({txid}: { txid: string }): Promise<any>;
+    getMemPoolInfo(): Promise<any>;
+    getRawMemPool({verbose}: { verbose?: number }): Promise<any>;
+    getTxOut({txid, voutNumber, includeMempool}: { txid: string, voutNumber: number, includeMempool?: boolean }): Promise<any>;
+    getTxOutProof({txids, blockHash}: { txids: Array<string>, blockHash: string }): Promise<any>;
+    getTxOutSetInfo(): Promise<any>;
+    preciousBlock({blockHash}: { blockHash: string }): Promise<any>;
+    pruneBlockchain({blockHeight}: { blockHeight: number }): Promise<any>;
+    saveMemPool(): Promise<any>;
+    scanTxOutSet({action, scanObjects}: { action: string, scanObjects: Array<any>}): Promise<any>;
+    verifyChain({checkLevel, numberOfBlocksToCheck}: { checkLevel?: number, numberOfBlocksToCheck?: number }): Promise<any>;
+    verifyTxOutProof({proof}: { proof: string }): Promise<any>;
+
+    // == Control ==
+    getMemoryInfo({mode}: { mode?: string }): Promise<any>;
+    getRpcInfo(): Promise<any>;
+    help({command}: { command?: string }): Promise<any>;
+    logging({includeCategories, excludeCategories}: { includeCategories?: Array<string>, excludeCategories: Array<string> }): Promise<any>;
+    stop(): Promise<any>;
+    uptime(): Promise<any>;
+
+    // == Generating ==
+    generate({numberOfBlocks, maxTries}: { numberOfBlocks: number, maxTries?: number }): Promise<any>;
+    generateToAddress({numberOfBlocks, address, maxTries}: { numberOfBlocks: number, address: string, maxTries?: number }): Promise<any>;
+
+    // == Mining ==
+    createAuxBlock({address}: { address: string }): Promise<any>;
+    getAuxBlock({blockHash, auxPow}: { blockHash?: string, auxPow?: string }): Promise<any>;
+    getBlockTemplate({blockTemplate}: { blockTemplate: string }): Promise<any>;
+    getMiningInfo(): Promise<any>;
+    getNetworkHashesPerSecond({numberOfBlocks, blockHeight}: { numberOfBlocks: number, blockHeight: number }): Promise<any>;
+    prioritiseTransaction({txid, dummy, feeDeltaInSatoshis}: { txid: string, dummy?: null, feeDeltaInSatoshis: number }): Promise<any>;
+    submitAuxBlock({blockHash, auxPow}: { blockHash: string, auxPow: string }): Promise<any>;
+    submitBlock({hexDataToSubmit}: { hexDataToSubmit: string }): Promise<any>;
+    submitHeader({hexData}: { hexData: string }): Promise<any>;
+
+    // == Network ==
+    addNode({nodeAddress}: { nodeAddress: string }): Promise<any>;
+    clearBanned(): Promise<any>;
+    disconnectNode({nodeAddress, nodeId}: { nodeAddress: string, nodeId: number }): Promise<any>;
+    getAddedNodeInfo({nodeAddress}: { nodeAddress: string }): Promise<any>;
+    getConnectionCount(): Promise<any>;
+    getNetTotals(): Promise<any>;
+    getNetworkInfo(): Promise<any>;
+    getNodeAddresses(): Promise<any>;
+    getPeerInfo(): Promise<any>;
+    getInfo(): Promise<any>;
+    listBanned(): Promise<any>;
+    ping(): Promise<any>;
+    setBan({subnet,command,banTime}: { subnet: string, command: string, banTime?: number}):Promise<any>;
+
+    // == Rawtransactions ==
+    analyzePsbt({pbst}: { pbst: string }): Promise<any>;
+    combinePsbt({pbsts}: { pbsts: Array<string> }): Promise<any>;
+    combineRawTransaction({hexs}: { hexs: Array<string> }): Promise<any>;
+    convertToPsbt({hex, permitSigData, isWitness}: { hex: string, permitSigData?: number, isWitness?: number }): Promise<any>;
+    createPsbt({txHeaders, payloadInfo, locktime, replaceable}: { txHeaders: Array<TxHeader>, payloadInfo: Array<PbstPayloadInfo>, locktime?: number, replaceable?: number }): Promise<any>;
+    createRawTransaction({txHeaders, payloadInfo, locktime, replaceable}: { txHeaders: Array<TxHeader>, payloadInfo: Array<PbstPayloadInfo>, locktime?: number, replaceable?: number }): Promise<any>;
+    decodePsbt({pbst}: { pbst: string }): Promise<any>;
+    decodeRawTransaction({hexString, isWitness}: { hexString: string, isWitness: number }): Promise<any>;
+    decodeScript({hexString}: { hexString: string }): Promise<any>;
+    finalizePsbt({pbst, extract}: { pbst: string, extract?: number }): Promise<any>;
+    fundRawTransaction({hexString, options, isWitness}: { hexString: string, options?: number, isWitness?: number }): Promise<any>;
+    getRawTransaction({txid, verbose, blockHash}: { txid: string, verbose?: number, blockHash?: string }): Promise<any>;
+    joinPsbts({pbsts}: { pbsts: Array<string> }): Promise<any>;
+    sendRawTransaction({hexString, maxFeeRate}: { hexString: string, maxFeeRate?: number }): Promise<any>;
+    signRawTransactionWithKey({hexString, privateKeys, txs, sigHashType}: { hexString: string, privateKeys: Array<string>, txs?: Array<Transaction>, sigHashType?: string }): Promise<any>;
+    testMempoolAccept({rawTxs, maxFeeRate}: { rawTxs: Array<string>, maxFeeRate?: number }): Promise<any>;
+    utxoUpdatePsbt({pbst}: { pbst: string }): Promise<any>;
+
+    // == Syscoin ==
+    addressBalance({address}: { address: string }): Promise<any>;
+    assetAllocationBalance({assetGuid, address}: { assetGuid: number, address: string }): Promise<any>;
+    assetAllocationBurn({assetGuid, address, amount, ethAddress}: { assetGuid: number, address: string, amount: number, ethAddress: string }): Promise<any>;
+    assetAllocationInfo({assetGuid, address}: { assetGuid: number, address: string }): Promise<any>;
+    assetAllocationLock({assetGuid, addressFrom, txid, outputIndex, witness}: { assetGuid: number, addressFrom: string, txid: string, outputIndex: number, witness?: string }): Promise<any>;
+    assetAllocationMint({assetGuid, address, amount, blockNum, txHex, txRootHex, merkleProofHex, merkleProofPathHex, witness}: { assetGuid: number, address: string, amount: number, blockNum: number, txHex: string, txRootHex: string, merkleProofHex: string, merkleProofPathHex: string, witness?: string }): Promise<any>;
+    assetAllocationSend({assetGuid, addressFrom, addressTo, amount}: { assetGuid: number, addressFrom: string, addressTo: string, amount: number }): Promise<any>;
+    assetAllocationSenderStatus({assetGuid, address, txid}: { assetGuid: number, address: string, txid: string }): Promise<any>;
+    assetAllocationSendMany({assetGuid, addressFrom, allocations, witness}: { assetGuid: number, addressFrom: string, allocations: Array<AssetAllocationSend>, witness?: string }): Promise<any>;
+    assetInfo({assetGuid}: { assetGuid: number }): Promise<any>;
+    assetNew({address, publicValue, contract, precision, supply, maxSupply, updateFlags, witness}: { address: string, publicValue: string, contract: string, precision: number, supply: number, maxSupply: number, updateFlags: number, witness: string }): Promise<any>;
+    assetSend({assetGuid, addressTo, amount}: { assetGuid: number, addressTo: string, amount: number }): Promise<any>;
+    assetSendMany({assetGuid, allocations, witness}: { assetGuid: number, allocations: Array<AssetAllocationSend>, witness?: string }): Promise<any>;
+    assetTransfer({assetGuid, address, witness}: { assetGuid: number, address: string, witness: string }): Promise<any>;
+    assetUpdate({assetGuid, publicValue, contract, supply, updateFlags, witness}: { assetGuid: number, publicValue: string, contract: string, supply: number, updateFlags: number, witness: string }): Promise<any>;
+    convertAddress({address}: { address: string }): Promise<any>;
+    getBlockHashByTxid({txid}: { txid: string }): Promise<any>;
+    getGovernanceInfo(): Promise<any>;
+    getSuperblockBudget({index}: { index: number }): Promise<any>;
+    gObject({command}: { command: string }): Promise<any>;
+    listAssetAllocationMempoolBalances({count, from, query}: { count?: number, from?: number, query?: AssetAllocationBalanceQuery }): Promise<any>;
+    listAssetAllocations({count, from, query}: { count?: number, from?: number, query?: AssetAllocationBalanceQueryWithGuid }): Promise<any>;
+    listAssetIndex({page, options}: { page?: number, options?: ListAssetIndexOptions }): Promise<any>;
+    listAssetIndexAllocations({address}: { address: string }): Promise<any>;
+    listAssetIndexAssets({address}: { address: string }): Promise<any>;
+    listAssets({count, from, options}: { count?: number, from?: number, options?: ListAssetOptions }): Promise<any>;
+    masternode({command}: { command: string }): Promise<any>;
+    masternodeBroadcast({command}: { command: string }): Promise<any>;
+    masternodeList({mode, filter}: { mode?: string, filter?: string }): Promise<any>;
+    mnSync({command}: { command: string }): Promise<any>;
+    sentinelPing({version}: { version: number }): Promise<any>;
+    spork({command}: { command: string }): Promise<any>;
+    syscoinBurn({fundingAddress, amount, ethAddress}: { fundingAddress: string, amount: number, ethAddress: string }): Promise<any>;
+    syscoinDecodeRawTransaction({hexString}: { hexString: number }): Promise<any>;
+    syscoinGetSpvProof({txid, blockHash}: { txid: string, blockHash?: string }): Promise<any>;
+    syscoinListReceivedByAddress({}: {}): Promise<any>;
+    syscoinMint({address, amount, blockNum, txHex, txRootHex, txMerkleProofHex, witness}: { address: string, amount: number, blockNum: number, txHex: string, txRootHex: string, txMerkleProofHex: string, witness?: string }): Promise<any>;
+    syscoinSetEthHeaders({headers}: { headers: EthHeaders }): Promise<any>;
+    syscoinSetEthStatus({syncStatus, highestBlock}: { syncStatus: string, highestBlock: number }): Promise<any>;
+    syscoinStartGeth({}: {}): Promise<any>;
+    syscoinStopGeth({}: {}): Promise<any>;
+    syscoinTxFund({hexString, address, outputIndex}: { hexString: string, address: string, outputIndex: number }): Promise<any>;
+    tpsTestAdd({startTime, rawTxs}: { startTime, rawTxs?: Array<TpsRawTx> }): Promise<any>;
+    tpsTestInfo({}: {}): Promise<any>;
+    tpsTestSetEnabled({enabled}: { enabled: number }): Promise<any>;
+    voteRaw({mnTxHash, mnTxIndex, govHash, votSignal, vote, time, voteSig}: { mnTxHash: string, mnTxIndex: number, govHash: string, votSignal: string, vote: string, time: number, voteSig: string }): Promise<any>;
+
+    // == Util ==
+    createMultiSig({numberOfRequiredSignatures, keys, addressType}: { numberOfRequiredSignatures: number, keys: Array<string>, addressType?: string }): Promise<any>;
+    deriveAddress({descriptor, range}: { descriptor: string, range?: number }): Promise<any>;
+    estimateSmartFee({confTarget, estimateMode}: { confTarget: number, estimateMode?: string }): Promise<any>;
+    getDescriptorInfo({descriptor}: { descriptor: string }): Promise<any>;
+    signMessageWithPrivKey({privateKey, message}: { privateKey: string, message: string }): Promise<any>;
+    validateAddress({address}: { address: string }): Promise<any>;
+    verifyMessage({address, signature, message}: { address: string, signature: string, message: string }): Promise<any>;
+
+    // == Wallet ==
+    abandonTransaction({txid}: { txid: string }): Promise<any>;
+    abortRescan(): Promise<any>;
+    addMultiSigAddress({nRequired, keys, label, addressType}: { nRequired: number, keys: Array<string>, label?: string, addressType?: string }): Promise<any>;
+    backupWallet({destination}: { destination: string }): Promise<any>;
+    bumpFee({txid, options}: { txid: string, options?: any }): Promise<any>;
+    createWallet({walletName, disablePrivKeys}: { walletName: string, disablePrivKeys: number }): Promise<any>;
+    dumpPrivKey({address}: { address: string }): Promise<any>;
+    dumpWallet({fileName}: { fileName: string }): Promise<any>;
+    encryptWallet({passphrase}: { passphrase: string }): Promise<any>;
+    getAddressesByLabel({label}: { label: string }): Promise<any>;
+    getAddressInfo({address}: { address: string }): Promise<any>;
+    getBalance({dummy, minconf, includeWatchOnly}: { dummy?: string, minconf: number, includeWatchOnly: number }): Promise<any>;
+    getNewAddress({label, addressType}: { label: string, addressType: string }): Promise<any>;
+    getRawChangeAddress({addressType}: { addressType?: string }): Promise<any>;
+    getReceivedByAddress({address, minConf}: { address: string, minConf?: number }): Promise<any>;
+    getReceivedByLabel({label, minConf}: { label: string, minConf?: number }): Promise<any>;
+    getTransaction({txid, includeWatchOnly}: { txid: string, includeWatchOnly: number }): Promise<any>;
+    getUnconfirmedBalance({}: {}): Promise<any>;
+    getWalletInfo({}: {}): Promise<any>;
+    importAddress({address, label, rescan, p2sh}: { address: string, label?: string, rescan?: number, p2sh?: number }): Promise<any>;
+    importMulti({requests, options}: { requests: string, options: any }): Promise<any>;
+    importPrivKey({key, label, rescan}: { key: string, label?: string, rescan?: number }): Promise<any>;
+    importPrunedFunds({rawTx, txOutProof}: { rawTx: string, txOutProof: string }): Promise<any>;
+    importPubKey({pubKey, label, rescan}: { pubKey: string, label?: string, rescan?: number }): Promise<any>;
+    importWallet({fileName}: { fileName: string }): Promise<any>;
+    keypoolRefill({newSize}: { newSize?: number }): Promise<any>;
+    listAddressGroupings({}: {}): Promise<any>;
+    listLabels({purpose}: { purpose?: string }): Promise<any>;
+    listLockUnspent({}: {}): Promise<any>;
+    listReceivedByAddress({minConf, includeEmpty, includeWatchOnly, addressFilter}: { minConf?: number, includeEmpty?: number, includeWatchOnly?: number, addressFilter?: string }): Promise<any>;
+    listReceivedByLabel({minConf, includeEmpty, includeWatchOnly}: { minConf?: number, includeEmpty?: number, includeWatchOnly?: number }): Promise<any>;
+    listSinceBlock({blockHash, targetConfs, includeWatchOnly, includeRemoved}: { blockHash?: string, targetConfs?: number, includeWatchOnly?: number, includeRemoved?: number }): Promise<any>;
+    listTransactions({label, count, skip, includeWatchOnly}: { label?: string, count?: number, skip?: number, includeWatchOnly?: number }): Promise<any>;
+    listUnspent({minConf, maxConf, addresses, includeUnsafe, query, options}: { minConf?: number, maxConf?: number, addresses?: Array<string>, includeUnsafe?: number, query?: any, options?: any }): Promise<any>;
+    listWalletDir({}: {}): Promise<any>;
+    listWallets({}: {}): Promise<any>;
+    loadWallet({fileName}: { fileName: string }): Promise<any>;
+    lockUnspent({unlock, txs}: { unlock: number, txs?: Array<{ txid: string, vout: number }> }): Promise<any>;
+    removePrunedFunds({txid}: { txid: string }): Promise<any>;
+    rescanBlockchain({start, stop}: { start?: number, stop?: number }): Promise<any>;
+    sendMany({dummy, amounts, minConf, comment, subtractFeeFrom, replaceable, confTarget, estimateMode}: { dummy: string, amounts: Array<{ [address: string]: number }>, minConf?: number, comment?: string, subtractFeeFrom?: Array<string>, replaceable?: boolean, confTarget?: number, estimateMode?: string }): Promise<any>;
+    sendToAddress({address, amount, minConf, comment, comment_to, subtractFeeFromAmount, replaceable, confTarget, estimateMode}: { address: string, amount: number, minConf?: number, comment?: string, comment_to?: string, subtractFeeFromAmount?: number, replaceable?: boolean, confTarget?: number, estimateMode?: string }): Promise<any>;
+    setHdSeed({newKeyPool, seed}: { newKeyPool?: number, seed?: string }): Promise<any>;
+    setLabel({address, label}: { address: string, label: string }): Promise<any>;
+    setTxFee({amount}: { amount: number }): Promise<any>;
+    signMessage({address, message}: { address: string, message: string }): Promise<any>;
+    signRawTransactionWithWallet({hexString, rawTxs, sigHashType}: { hexString: string, rawTxs?: Array<RawTx>, sigHashType?: string }): Promise<any>;
+    unloadWallet({walletName}: { walletName?: string }): Promise<any>;
+    walletCreateFundedPsbt({txs, amounts, lockTime, options, bip32derivs}: { txs: any, amounts: any, lockTime?: any, options?: any, bip32derivs?: any }): Promise<any>;
+    walletLock({}: {}): Promise<any>;
+    walletPassphrase({passphrase, timeout}: { passphrase: string, timeout: number }): Promise<any>;
+    walletPassphraseChange({oldPass, newPass}: { oldPass: string, newPass: string }): Promise<any>;
+    walletProcessPsbt({pbst, sign, sigHashType, bip32derivs}: { pbst: string, sign?: number, sigHashType?: string, bip32derivs?: number }): Promise<any>;
+    // @formatter:on
+
+    callThroughToRpc(args): Promise<any>; //exposed for unit testing
+}
\ No newline at end of file
